\documentclass[a4paper, 11pt]{article}

\usepackage{fullpage}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{bussproofs}

\usepackage{syntax}

\usepackage{listings}


% Document information

\def\version{0.1.0}

\def\thetitle{Tiny Grace Formal Specification}
\def\theauthor{Timothy Jones}

\usepackage[
    pdftitle={\thetitle},
    pdfauthor={\theauthor},
    colorlinks,
    urlcolor=black,
    linkcolor=black,
    citecolor=black
]{hyperref}


% Math definitions

\def\H{\mathcal{H}}
\def\M{\mathcal{M}}
\def\O{\mathcal{O}}

\def\G{\Gamma}
\newcommand{\ctx}[3]{#1 \vdash #2 : #3}
\newcommand{\gctx}[2]{\ctx{\G}{#1}{#2}}
\newcommand{\ectx}[2]{\ctx{\varnothing}{#1}{#2}}

\def\sub{<\kern-1pt:}

\def\bo{{\sffamily\upshape\{}}
\def\bc{{\sffamily\upshape\}}}
\def\po{{\sffamily\upshape(}}
\def\pc{{\sffamily\upshape)}}

\newcommand{\key}[1]{{\sffamily\bfseries#1}}
\newcommand{\object}[1]{\text{\key{object}\bo}#1\text{\bc}}
\newcommand{\methh}[2]{\text{\key{method} }#1\ \text{\bo}#2\text{\bc}}
\newcommand{\method}[4]{\methh{#1\text{\po}#2\text{\pc }\to #3}{#4}}
\newcommand{\type}[1]{\text{\bo}#1\text{\bc}}
\newcommand{\self}{\text{\key{self}}}

\def\rto{\overset{_\mathcal{R}}\longrightarrow}
\def\rtot{\overset{_{\mathcal{R}^*}}{\longrightarrow}}
\def\sto{\overset{_\mathcal{S}}\longrightarrow}
\def\stot{\overset{_{\mathcal{S}^+}}\longrightarrow}

\def\xs{\overset{_\text{\sffamily\bfseries s}}x}


% Listings settings

\lstdefinelanguage{TinyGrace}{%
    keywords={object, method, self},
    sensitive=true
}

\lstset{%
    basicstyle=\sffamily,
    keywordstyle=\bfseries,
    xleftmargin=10mm,
    columns=fullflexible,
    escapechar=\%,
    language=TinyGrace,
    literate={->\ }{$\to$ }1
}


% Theorem definitions

\newtheoremstyle{theorem}{}{}{\itshape}{}{}{.}{.5em}
    {\thmname{\textsc{#1}}\thmnumber{\ #2}\thmnote{\ ({#3})}}
\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}

\newtheoremstyle{lemma}{}{}{\itshape\addtolength{\leftskip}{1em}}{}{}{.}{.5em}
    {\thmname{\textsc{#1}}\thmnumber{\ #2}\thmnote{\ ({#3})}}
\theoremstyle{lemma}
\newtheorem{lemma}{Lemma}[theorem]

\newtheoremstyle{tproof}{}{}{}{}{}{.}{.5em}
    {\thmname{\textsc{#1}}\thmnumber{\ #2}\thmnote{\ ({#3})}}
\theoremstyle{tproof}
\newtheorem*{tproof}{Proof}

\newtheoremstyle{lproof}{}{}{\addtolength{\leftskip}{1em}}{}{}{.}{.5em}
    {\thmname{\textsc{#1}}\thmnumber{\ #2}\thmnote{\ ({#3})}}
\theoremstyle{lproof}
\newtheorem*{lproof}{Proof}

\newtheoremstyle{tcase}{}{}{\addtolength{\leftskip}{1em}}{}{}{.}{.5em}
    {\thmname{\textit{#1}}\thmnote{\ \textsc{#3}}}
\theoremstyle{tcase}
\newtheorem*{tcase}{Case}

\newtheoremstyle{lcase}{}{}{\addtolength{\leftskip}{3em}}{-1em}{}{}{.5em}
    {\thmname{\textit{#1}}\thmnote{\ \textsc{#3}}\hspace*{\fill}\\}
\theoremstyle{lcase}
\newtheorem*{lcase}{Case}


\title{\thetitle\\\normalsize\vspace{0.5em}Version \version\vspace{-0.5em}}
\author{\theauthor}

\bibliographystyle{acm}

\begin{document}
\maketitle

\section{Introduction}

Tiny Grace is a tiny subset of the Grace programming language, in the spirit of
Featherweight Java \cite{fj}.  It currently aims to resolve the following
issues:

\begin{itemize}

\item Simple reduction semantics

\item Static typing

\end{itemize}

\noindent Future versions will aim to extend the formalism to address:

\begin{itemize}

\item Safe casting with match-case

\item Type aliases for recursive types

\item Inheritance semantics and typing

\item Dialect semantics

\item Statements and early returns

\item Block semantics and typing

\item Dynamic typing and runtime semantics

\end{itemize}

\noindent Tiny Grace intentionally avoids the following issues:

\begin{itemize}

\item Concrete syntax and sugar, such as mixfix declarations and classes

\item Variables and the heap

\item Generic and inferred types

\item Annotations and reflection

\end{itemize}

\noindent The current version of Tiny Grace is much simpler than Featherweight
Java in most aspects, as it does not feature constructors, fields, or casts, and
does not need to maintain a class table.  Instead of these features, it must
implement scope, as objects can be nested.  This requires a more complicated
substitution algorithm which can substitute both variables and \self, but with
only variables crossing object boundaries.  As the language does not feature
casting, type soundness guarantees program completion, whereas FJ may halt on
invalid casts.  Without match-case casting Tiny Grace is strictly less powerful
than FJ, as lost type information cannot be recovered, and recursive types
cannot be expressed.


\section{Syntax}

\def\*#1*{$\overline{#1}$}

The abstract syntax for Tiny Grace can be found in
Figure~\ref{fig:abstract-syntax}.  The metavariable $\M$ ranges over methods;
$\O$ over object literals; $x$ and $y$ over variable names; $\xs$ over both
variable names and the {\sffamily\bfseries self} keyword; $\tau$, $\sigma$ and
$\upsilon$ over types; $\H$ over method headers, $m$ over method names, and $e$
over expressions.  We write \*e* to indicate a possibly empty sequence of
comma-separated expressions $e_1, \dots, e_n$, as well as for method header
parameters \*x : \tau*.  We also write \*\H* and \*\M* to indicate a possibly
empty set of method headers $\H_1 \dots \H_n$ and $\M_1 \dots \M_n$
respectively.

\begin{figure}
\centering

\def\*#1*{$\overline{\text{#1}}$}
\def\<#1>{$#1$}

\grammarindent3.4em
\renewcommand{\grammarlabel}[2]{$#1$\hfill#2}
\renewcommand{\syntleft}{\itshape}
\renewcommand{\syntright}{}
\renewcommand{\ulitleft}{\sffamily\bfseries}
\renewcommand{\litleft}{\sffamily}
\renewcommand{\litright}{}

\begin{grammar}
<\M> ::= "method" $\H$ \bo~\<e> \bc

<\O> ::= "object" \bo~\*$\M$* \bc

<\H> ::= <m>`('\*\<x> $:$ $\tau$*`)' $\to$ $\tau$

<\tau> ::= \bo~\*$\H$* \bc

<e> ::= <x> | "self" | <e>`.'<m>(\*\<e>*) | $\O$
\end{grammar}

\caption{Tiny Grace abstract syntax}
\label{fig:abstract-syntax}

\end{figure}

A Tiny Grace program consists of a pair containing an object body \*\M* and an
expression $e$ which will be evaluated in the scope of \*\M*.  Consider the
following object body:

\begin{lstlisting}
method pair%%(fst : {}, snd : {}) -> { fst() -> {}, snd() -> {} } {
    object %%{
        method fst%%() -> {} { fst }
        method snd%%() -> {} { snd }
    %%}
%%}
\end{lstlisting}

\noindent The following expression can be evaluated in that body's scope:

\begin{lstlisting}
self.pair%%(object {}, object {
    method run%%(obj : { apply() -> {} }) -> {} { obj.apply() }
%%}).snd()
\end{lstlisting}

\noindent The outcome will be the following object:

\begin{lstlisting}
object %%{
    method run%%(obj : { apply() -> {} }) -> {} { obj.apply() }
%%}
\end{lstlisting}


\def\*#1*{\overline{#1}}

\section{Typing}

\begin{figure}
\centering

\begin{equation}
\tag{\textsc{T-Sub}}\label{eq:type-sub}
\AxiomC{$\*\H* \subseteq \*\H^\prime*$}
\UnaryInfC{\bo~$\*\H^\prime*$ \bc~$\sub$ \bo~$\*\H*$ \bc}
\DisplayProof
\end{equation}

\caption{Tiny Grace subtyping}
\label{fig:subtyping}

\end{figure}

\begin{figure}
\centering

\begin{equation}
\tag{\textsc{T-Var}}\label{eq:type-var}
\AxiomC{$\gctx{\xs}{\G(\xs)}$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{T-Req}}\label{eq:type-req}
\AxiomC{$\gctx{e}{\type{\*\H_i*}}$}
\AxiomC{$m(\*x_i : \upsilon_i*) \to \sigma \in \*\H_i*$}
\AxiomC{$\gctx{\*e_i}{\upsilon^\prime_i}*$}
\AxiomC{$\*\upsilon^\prime_i \sub \upsilon_i*$}
\QuaternaryInfC{$\gctx{e.m(\*e_i*)}{\sigma}$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{T-Obj}}\label{eq:type-obj}
\AxiomC{$\G, \self : \type{\*\H_i*} \vdash \*\methh{\H_i}{e_i}~\mathrm{OK}*$}
\UnaryInfC{$\gctx{\object{\*\methh{\H_i}{e_i}*}}{\type{\*\H_i*}}$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{T-Meth}}\label{eq:type-meth}
\AxiomC{$\*x_i \notin \G*$}
\AxiomC{$\ctx{\G, \*x_i : \upsilon_i*}{e}{\sigma^\prime}$}
\AxiomC{$\sigma^\prime \sub \sigma$}
\TrinaryInfC{$\G \vdash \method{m}{\*x_i : \upsilon_i*}{\sigma}{e}~\mathrm{OK}$}
\DisplayProof
\end{equation}

\caption{Tiny Grace typing rules}
\label{fig:typing}

\end{figure}


\section{Reduction}

\subsection{Substitution}

\begin{figure}
\centering

\begin{align}
\tag{\textsc{S-Var}}\label{eq:sub-var}
[\O/\xs]\xs              &\sto \O \\
\tag{\textsc{S-None}}\label{eq:sub-none}
[\O/\xs]y                &\sto y \quad \mathbf{if}\ \xs \neq y \\
\tag{\textsc{S-Req}}\label{eq:sub-req}
[\O/\xs]e.m(\*e_i*)      &\sto ([\O/\xs]e).m(\*[\O/\xs]e_i*) \\
\tag{\textsc{S-Obj}}\label{eq:sub-obj}
[\O/x]\object{\*\M*}     &\sto \object{\*[\O/x]\M*} \\
\tag{\textsc{S-Self}}\label{eq:sub-self}
[\O/\self]\object{\*\M*} &\sto \object{\*\M*} \\
\tag{\textsc{S-Meth}}\label{eq:sub-meth}
[\O/x]\method{m}{\*y_i : \upsilon_i*}{\sigma}{e} &\sto \method{m}{\*y_i : \upsilon_i*}{\sigma}{[\O/x]e}
\end{align}

\caption{Tiny Grace substitution rules}
\label{fig:substitution}

\end{figure}

\subsection{Reduction Rules}

Given a Tiny Grace program $(\*\M*, e)$, we can reduce $e$ in the scope of
$\*\M*$ by applying the substitution rules given in
Figure~\ref{fig:substitution} to the expression $[\object{\*\M*}/\self]e$, and
then applying the reduction rules given in Figure~\ref{fig:reduction} to the
result.

\begin{figure}
\centering

\begin{equation}
\tag{\textsc{R-Rec}}\label{eq:red-rec}
\AxiomC{$e \rto e^\prime$}
\UnaryInfC{$e.m(\*e_i*) \rto e^\prime.m(\*e_i*)$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{R-Arg}}\label{eq:red-arg}
\AxiomC{$e_i \rto e_i^\prime$}
\UnaryInfC{$\O.m(\dots, e_i, \dots) \rto \O.m(\dots, e_i^\prime, \dots)$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{R-Req}}\label{eq:red-req}
\AxiomC{$\method{m}{\*x_i : \upsilon_i*}{\sigma}{e} \in \*\M*$}
\UnaryInfC{$\object{\*\M*}.m(\*\O_i*) \rto [\*\O_i/x_i*,\ \object{\*\M*}/\self]e$}
\DisplayProof
\end{equation}

\caption{Tiny Grace reduction rules}
\label{fig:reduction}

\end{figure}


\section{Properties}

\begin{theorem}[Progress]
\label{th:progress}

Every well-typed expression is either an object literal or can be reduced by an
application of $\rto$.

\begin{lemma}[Substitution Completeness]
\label{lem:sub-complete}

Substitution on a well-typed term always completes.

\begin{lproof}
A well-typed program must have a finite size, which means every branch must
bottom out on either a variable, \self, or an empty object literal, all of which
terminate substitution. \qed
\end{lproof}

\end{lemma}

\begin{tproof}

$\xs$ is never well-typed in an empty context.  An inductive step for method
requests is trivial, so we need only show that a method request whose receiver
and arguments are all object literals can always proceed and will always
complete.  Rule~\ref{eq:type-obj} guarantees that the requested method always
exists in the receiver, which is the only requirement for $\rto$ to be applied
to this form of method request.  Due to Lemma~\ref{lem:sub-complete}, this
single step of $\rto$ is guaranteed to complete and produce a new expression
$e^\prime$. \qed

\end{tproof}

\end{theorem}

\begin{theorem}[Preservation]
\label{th:preservation}

If $\gctx{e}{\tau}$ and $e \rto e^\prime$, then $\gctx{e^\prime}{\tau^\prime}$
for some $\tau^\prime \sub \tau$.

\begin{lemma}
\label{lem:submethod}

If $\H \in \*\H_i*$, then $\H \in \*\H^\prime_i*$ for all
$\type{\*\H^\prime_i*} \sub \type{\*\H_i*}$.

\begin{lproof}
Follows from Rule~\ref{eq:type-sub}. \qed
\end{lproof}

\end{lemma}

\begin{lemma}[Substitution Preservation]
\label{lem:preservation}

If $\ctx{\G, \xs : \upsilon}{e}{\tau}$, and $\gctx{e^\prime}{\upsilon^\prime}$
where $\upsilon^\prime \sub \upsilon$, then
$\gctx{[e^\prime/\xs]e}{\tau^\prime}$ for some $\tau^\prime \sub \tau$.

\begin{lproof}

By induction on the derivation of $\ctx{\G, \xs : \upsilon}{e}{\tau}$.

\begin{lcase}[S-Var: $e = \xs$]
$\ctx{\G, e : \upsilon}{e}{\upsilon}$, so $\tau = \upsilon$.
$[e^\prime/\xs]e \sto e^\prime$ and $\gctx{e^\prime}{\upsilon^\prime}$, so
$\tau^\prime = \upsilon^\prime$.  As
$\upsilon^\prime \sub \upsilon$, $ \tau^\prime \sub \tau$.
\end{lcase}

\begin{lcase}[S-None: $e = y~\mathbf{where}~y \neq \xs$]
$[e^\prime/\xs]e \sto e$ and $\gctx{e}{\tau}$, so
$\tau^\prime = \tau$.  As $\sub$ is reflexive, $\tau^\prime \sub \tau$.
\end{lcase}

\begin{lcase}[S-Req: $e = e_0.m(\*e_i*)$]
$e_0 \sto e^\prime_0$ and $\*e_i \sto e^\prime_i*$ where
$\Gamma, \xs : \upsilon \vdash e^\prime_0 : \sigma, \*e^\prime_i : \upsilon^\prime*$.
\end{lcase}

\begin{lcase}[S-Obj/S-Meth: $e = \object{\*\M_i*}, \xs = x$]
Trivial inductive step.
\end{lcase}

\begin{lcase}[S-Self: $e = \object{\*\M_i*}, \xs = \self$]
$[e^\prime/\self]e \sto e$ and $\gctx{e}{\tau}$, so
$\tau^\prime = \tau$.  As $\sub$ is reflexive, $\tau^\prime \sub \tau$. \qed
\end{lcase}

\end{lproof}

\end{lemma}

\begin{tproof}

By induction on a derivation of $e \rto e^\prime$.  The inductive step for
\textsc{R-Rec} and \textsc{R-Arg} is trivial, so only \textsc{R-Req} remains.
\begin{align*}
&e = \object{\*\M_i*}.m(\*\O_i*) &
\method{m}{\*x_i : \upsilon_i*}{\sigma}{e_m} \in \*\M_i* \\
&e^\prime = [\*\O_i/x_i*, \object{\*\M_i*}/\self]e_m &
\end{align*}

\noindent By Rules~\ref{eq:type-req} and~\ref{eq:type-obj}, for some types
$\*\upsilon^\prime_i*$ we have:
\begin{displaymath}
\G \vdash \object{\*\methh{\H_j}{e_j}*} : \type{\*\H_j*} \quad\quad
m(\*x_i : \upsilon_i*) \to \sigma \in \*\H_j* \quad\quad
\G \vdash \*\O_i : \upsilon^\prime_i* \quad\quad
\*\upsilon^\prime_i \sub \upsilon_i*
\end{displaymath}

\noindent By Lemma~?
$\*x_i : \upsilon_i*, \self : \type{\H_i} \vdash e_m : \tau$ for some type
$\tau$ where $\tau \sub \sigma$.  By Lemma~?,
$\G, \*x_i : \upsilon_i*, \self : \type{\H_i} \vdash e_m : \tau$.  Then, by
Lemma~\ref{lem:preservation},
$\G \vdash [\*\O_i/x_i,\O/\self*]e_m : \tau^\prime$ for some type
$\tau^\prime \sub \tau$.  $\tau^\prime$ is a subtype of $\sigma$ by transitivity
of $\sub$. \qed

\end{tproof}

\end{theorem}

\begin{theorem}[Type Soundness]
\label{th:type-soundness}

If $\varnothing \vdash e : \tau$ and $e \rtot e^\prime$ with $e^\prime$ in
normal form, then $e^\prime$ is an object literal $\O$ with
$\varnothing \vdash \O : \tau^\prime$ where $\tau^\prime \sub \tau$.

\begin{tproof}
Immediate from Theorems~\ref{th:progress} and~\ref{th:preservation}. \qed
\end{tproof}

\end{theorem}


\bibliography{references}

\end{document}

