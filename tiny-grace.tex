\documentclass[a4paper, 11pt]{article}

\usepackage{fullpage}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{bussproofs}

\usepackage{syntax}


% Document information

\def\version{0.1.0}

\def\thetitle{Tiny Grace Formal Specification}
\def\theauthor{Timothy Jones}

\usepackage[
pdftitle={\thetitle},
pdfauthor={\theauthor},
colorlinks,
urlcolor=black,
linkcolor=black,
citecolor=black
]{hyperref}


% Math definitions

\def\H{\mathcal{H}}
\def\M{\mathcal{M}}
\def\O{\mathcal{O}}

\def\sub{<\kern-1pt:}

\def\bo{{\sffamily\{}}
\def\bc{{\sffamily\}}}
\def\po{{\sffamily(}}
\def\pc{{\sffamily)}}

\newcommand{\object}[1]{\text{{\sffamily\bfseries object}\bo}#1\text{\bc}}
\newcommand{\methh}[2]{\text{{\sffamily\bfseries method} }#1\ \text{\bo}#2\text{\bc}}
\newcommand{\method}[4]{\methh{#1\text{\po}#2\text{\pc }\to #3}{#4}}
\newcommand{\type}[1]{\text{\bo}#1\text{\bc}}
\newcommand{\self}{\text{\sffamily\bfseries self}}

\def\rto{~\overset{_\mathcal{R}}\longrightarrow~}
\def\sto{~\overset{_\mathcal{S}}\longrightarrow~}

\def\xs{\overset{_\text{\sffamily\bfseries s}}x}


\title{\thetitle\\\normalsize\vspace{0.5em}Version \version\vspace{-0.5em}}
\author{\theauthor}

\bibliographystyle{acm}

\begin{document}
\maketitle\vspace{-2em}

\section{Introduction}

Tiny Grace is a tiny subset of the Grace programming language, in the spirit of
Featherweight Java \cite{fj}.  It currently aims to resolve the following
issues:

\begin{itemize}

    \item Simple reduction semantics

    \item Static typing

\end{itemize}

\noindent Future versions will aim to extend the formalism to address:

\begin{itemize}

    \item Safe casting with match-case

    \item Inheritance semantics and typing

    \item Dialect semantics

    \item Statements and early returns

    \item Block semantics and typing

    \item Dynamic typing and runtime semantics

\end{itemize}

\noindent Tiny Grace intentionally avoids the following issues:

\begin{itemize}

    \item Concrete syntax and sugar, such as mixfix declarations and classes

    \item Variables and the heap

    \item Generic and inferred types

    \item Annotations and reflection

\end{itemize}

\noindent The current version of Tiny Grace is much simpler than Featherweight
Java in most aspects, as it does not feature constructors, fields, or casts, and
does not need to maintain a class table.  Instead of these features, it must
implement scope, as objects can be nested.  This requires a more complicated
substitution algorithm which substitutes variables across object boundaries, but
not $\self$.  As the language does not feature casting, type soundness
guarantees program completion, whereas FJ may halt on invalid casts.  Without
match-case casting it is strictly less powerful than FJ, as lost type
information cannot be recovered.


\section{Syntax}

\def\*#1*{$\overline{#1}$}

The abstract syntax for Tiny Grace can be found in
Figure~\ref{fig:abstract-syntax}.  The metavariable $\M$ ranges over methods;
$\O$ over object literals; $x$ and $y$ over variable names; $\xs$ over both
variable names and the {\sffamily\bfseries self} keyword; $\tau$ and $\sigma$
over types; $\H$ over method headers, $m$ over method names, and $e$ over
expressions.  We write \*e* to indicate a possibly empty sequence of
comma-separated expressions $e_1, \dots, e_n$, as well as for method header
parameters \*x : \tau*.  We also write \*\H* and \*\M* to indicate a possibly
empty set of method headers $\H_1 \dots \H_n$ and $\M_1 \dots \M_n$
respectively.

\begin{figure}
\centering

\def\*#1*{$\overline{\text{#1}}$}
\def\<#1>{$#1$}

\grammarindent3.4em
\renewcommand{\grammarlabel}[2]{$#1$\hfill#2}
\renewcommand{\syntleft}{\itshape}
\renewcommand{\syntright}{}
\renewcommand{\ulitleft}{\sffamily\bfseries}
\renewcommand{\litleft}{\sffamily}
\renewcommand{\litright}{}

\begin{grammar}
<\M> ::= "method" $\H$ \bo~\<e> \bc

<\O> ::= "object" \bo~\*$\M$* \bc

<\H> ::= <m>`('\*\<x> $:$ $\tau$*`)' $\to$ $\tau$

<\tau> ::= \bo~\*$\H$* \bc

<e> ::= <x> | "self" | <e>`.'<m>(\*\<e>*) | $\O$
\end{grammar}

\caption{Tiny Grace abstract syntax}
\label{fig:abstract-syntax}

\end{figure}

A Tiny Grace program consists of a pair containing an object body \*\M* and an
expression $e$ which will be evaluated in the scope of \*\M*.


\section{Typing}

\begin{figure}
\centering

\def\*#1*{\overline{#1}}

\begin{equation}
\tag{\textsc{T-Sub}}\label{eq:type-sub}
\AxiomC{$\*\H* \subseteq \*\H^\prime*$}
\UnaryInfC{\bo~$\*\H^\prime*$ \bc~$\sub$ \bo~$\*\H*$ \bc}
\DisplayProof
\end{equation}

\caption{Tiny Grace subtyping}
\label{fig:subtyping}

\end{figure}

\begin{figure}
\centering

\def\*#1*{\overline{#1}}

\begin{equation}
\tag{\textsc{T-Var}}\label{eq:type-var}
\AxiomC{$\Gamma \vdash \xs : \Gamma(\xs)$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{T-Req}}\label{eq:type-req}
\AxiomC{$\Gamma \vdash e : \tau$}
\AxiomC{$m(\*x_i : \sigma_i*) \to \sigma \in \tau$}
\AxiomC{$\Gamma \vdash \*e_i : \tau_i*$}
\AxiomC{$\*\tau_i \sub \sigma_i*$}
\QuaternaryInfC{$\Gamma \vdash e.m(\*e_i*) : \sigma$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{T-Obj}}\label{eq:type-obj}
\AxiomC{$\Gamma, \self : \type{\*\H_i*} \vdash \*\methh{\H_i}{e_i}~\mathrm{OK}*$}
\UnaryInfC{$\Gamma \vdash \object{\*\methh{\H_i}{e_i}*} : \type{\*\H_i*}$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{T-Meth}}\label{eq:type-meth}
\AxiomC{$\*x_i \notin \Gamma*$}
\AxiomC{$\Gamma, \*x_i : \tau_i* \vdash e : \sigma$}
\AxiomC{$\sigma \sub \tau$}
\TrinaryInfC{$\Gamma \vdash \method{m}{\*x_i : \tau_i*}{\tau}{e}~\mathrm{OK}$}
\DisplayProof
\end{equation}

\caption{Tiny Grace typing rules}
\label{fig:typing}

\end{figure}


\section{Reduction}

\def\*#1*{\overline{#1}}

Given a Tiny Grace program $(\*\M*, e)$, we can reduce $e$ in the scope of
$\*\M*$ by applying the substitution rules given in
Figure~\ref{fig:substitution} to the expression $[\object{\*\M*}/\self]e$, and
then applying the reduction rules given in Figure~\ref{fig:reduction} to the
result.


\begin{figure}
\centering

\def\*#1*{\overline{#1}}

\begin{align}
\tag{\textsc{S-Var}}\label{eq:sub-var}
[\O/\xs]\xs              &\sto \O \\
\tag{\textsc{S-None}}\label{eq:sub-none}
[\O/\xs]y                &\sto y \quad \mathbf{if}\ \xs \neq y \\
\tag{\textsc{S-Req}}\label{eq:sub-req}
[\O/\xs]e.m(\*e_i*)      &\sto [\O/\xs]e.m(\*[\O/\xs]e_i*) \\
\tag{\textsc{S-Obj}}\label{eq:sub-obj}
[\O/x]\object{\*\M*}     &\sto \object{\*[\O/x]\M*} \\
\tag{\textsc{S-Self}}\label{eq:sub-self}
[\O/\self]\object{\*\M*} &\sto \object{\*\M*} \\
\tag{\textsc{S-Meth}}\label{eq:sub-meth}
[\O/x]\method{m}{\*x_i : \tau_i*}{\sigma}{e} &\sto \method{m}{\*x_i : \tau_i*}{\sigma}{[\O/x]e}
\end{align}

\caption{Tiny Grace substitution rules}
\label{fig:substitution}

\end{figure}

\begin{figure}
\centering

\def\*#1*{\overline{#1}}

\begin{equation}
\tag{\textsc{R-Rec}}\label{eq:red-rec}
\AxiomC{$e \rto e^\prime$}
\UnaryInfC{$e.m(\*e_i*) \rto e^\prime.m(\*e_i*)$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{R-Arg}}\label{eq:red-arg}
\AxiomC{$e_i \rto e_i^\prime$}
\UnaryInfC{$\O.m(\dots, e_i, \dots) \rto \O.m(\dots, e_i^\prime, \dots)$}
\DisplayProof
\end{equation}

\begin{equation}
\tag{\textsc{R-Req}}\label{eq:red-req}
\AxiomC{$\method{m}{\*x_i : \tau_i*}{\sigma}{e}~\in~\*\M*$}
\UnaryInfC{$\object{\*\M*}.m(\*\O_i*) \rto [\*\O_i/x_i*,\ \object{\*\M*}/\self]e$}
\DisplayProof
\end{equation}

\caption{Tiny Grace reduction rules}
\label{fig:reduction}

\end{figure}


\bibliography{references}

\end{document}

